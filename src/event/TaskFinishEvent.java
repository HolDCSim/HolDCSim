package event;

import job.Job;
import job.Task;
import controller.WindowedSSEnforcer;
import debug.Sim;
import infrastructure.Server;
import infrastructure.Server.serverState;
import experiment.Experiment;
import experiment.SingletonJobExperiment;
import experiment.SleepScaleExperiment;
import experiment.WindowedSSExperiment;

/**
 * Represents a Task finishing on a server.
 * 
 * 
 */
public final class TaskFinishEvent extends TaskEvent {

	/**
	 * The serialization id.
	 */
	private static final long serialVersionUID = 1L;

	/**
	 * The speed at which the Task finish time was calculated.
	 */
	private double finishingSpeed;

	private Task task;

	// TODO (meisner@umich.edu) Figure out exactly how this works
	/**
	 * ...
	 */
	private double finishTimeSet;

	/**
	 * The server on which the Task finished.
	 */
	private Server server;

	// TODO

	/**
	 * Creates a new TaskFinishEvent.
	 * 
	 * @param time
	 *            - the time the Task finishes
	 * @param experiment
	 *            - the experiment the event is in
	 * @param task
	 *            - the finishing Task
	 * @param aServer
	 *            - the server the Task finished on
	 * @param theFinishTimeSet
	 *            - double check this
	 * @param theFinishSpeed
	 *            - the normalized speed at which the Task finishes
	 */
	public TaskFinishEvent(final double time, final Experiment experiment,
			final Task task, final Server aServer,
			final double theFinishTimeSet, final double theFinishSpeed) {
		super(time, experiment, task);
		this.server = aServer;
		task.setTaskFinishEvent(this);
		this.finishTimeSet = theFinishTimeSet;
		this.finishingSpeed = theFinishSpeed;
		this.task = task;
	}

	// TODO (meisner@umich.edu) Figure out exactly how this works
	/**
	 * ...
	 * 
	 * @return ...
	 */
	public double getFinishTimeSet() {
		return this.finishTimeSet;
	}

	/**
	 * Sets the normalized speed at which the Task finishes. 1.0 is no change in
	 * speed. 2.0 is twice as fast etc...
	 * 
	 * @param theFinishSpeed
	 *            - the normalized speed at which the Task finishes.
	 */
	public void setFinishSpeed(final double theFinishSpeed) {
		this.finishingSpeed = theFinishSpeed;
	}

	/**
	 * Get the speed at which the Task finishes.
	 * 
	 * @return the finish speed
	 */
	public double getFinishSpeed() {
		return this.finishingSpeed;
	}

	@Override
	public void printEventInfo() {
		Sim.debug(5,"Time: " + this.getTime() + ", Job "
				+ task.getJobId() + " Task " + task.getTaskId()
				+ " Finish event. Task " + task.getTaskId() + " size: "
				+ task.getSize() + ", in Server: " + server.getNodeId() + ".");
		//System.out.println("The task execution time is " + (this.time-task.getStartTime()));
		//System.out.println(this.time-task.getStartTime());

	}

	@Override
	public void process() {
		
//		System.out.println("Task Finishe");

		verbose();
		printEventInfo();
		this.getTask().markFinish(this.getTime());
		Sim.debug(5,"$$$ : task finished " + this.getTask().getJobId() + " Task "+ getTask().getTaskId() + this.getExperiment().printStateofServers());
		/**
		 * put it here so that when Socket is used as ActivityUnit, it is able
		 * to find out the core based on the task use TaskToCoreMap before the
		 * entry is removed from the map
		 */
		//collect server scope service time stats
		server.updateTaskStats(task);
		
		this.server.removeTask(this.getTime(), this.getTask());
//		if (this.server.getQueueLength() == 0) {
//
//			//System.out.println("activeEndTime"+getTime()+"server"+this.server.getNodeId());
//			this.server.setPowerState(serverState.OFF);
//			this.server.updateActiveTime(getTime());
//			this.server.setActiveEndTime(getTime());
//			this.server.setOffStartTime(getTime());
//		}

		/*
		 * order has been changed so that if this is the last task for the last
		 * job, some other events generated by server.remove will have the
		 * chance to be processed
		 */
		//Job job = experiment.getJobs().get((int) task.getJobId() - 1);
		Job job = task.getaJob();
		job.taskFinished(this.getTask(), this.getTime());


		//collect task latency and abs service time stats
		experiment.updateTaskStats(task);

		experiment.remainingJobs.remove(getTask().getTaskId());
		

		// collect statistics for Sleepscale experiment
		try {
			// SleepScaleExperiment ssExp = (SleepScaleExperiment) experiment;

			if (experiment instanceof WindowedSSExperiment) {
				WindowedSSEnforcer ssEnforce = ((WindowedSSExperiment) experiment)
						.getSSEnforcer();
				ssEnforce.incrementCompletedJobs();
			}

			if (experiment instanceof SleepScaleExperiment) {
				SleepScaleExperiment ssExp = ((SleepScaleExperiment) experiment);
			    ssExp.updateServieTimeStats(task);
				
			}
			
		} catch (ClassCastException e) {
			Sim.debug(1, "current experiment is not sleepscale experiment");

		}

	}
}
